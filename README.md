# Algorithm Visualizer

An interactive, step-by-step algorithm visualization platform that brings algorithms to life through dynamic visual representations. Perfect for students, educators, and developers looking to understand how algorithms work under the hood.

## üåê Live Demo
Experience the visualizer live: [Algorithm Visualizer](https://algorithm-visualizer-blush-nine.vercel.app/)

## ‚ú® Current Features

- **Step-by-Step Visualization**: Watch algorithms execute line by line with animated visual feedback
- **Interactive Controls**: Play, pause, step forward/backward through algorithm execution
- **Customizable Inputs**: Modify array values and algorithm parameters in real-time
- **Beautiful Dark Mode UI**: Modern, fuchsia-themed interface with smooth animations
- **Speed Control**: Adjust animation speed to match your learning pace
- **Responsive Design**: Works seamlessly across desktop and mobile devices

## üõ†Ô∏è Technologies Used

- **React** - Component-based UI architecture
- **Tailwind CSS** - Utility-first styling with custom fuchsia theme
- **Vite** - Fast development environment and optimized builds
- **Lucide React** - Beautiful, consistent icon system

## üì¶ Installation

```bash
# Clone the repository
git clone <repository-url>

# Navigate to project directory
cd algorithm-visualizer

# Install dependencies
npm install

# Start development server
npm run dev
```

The application will be available at `http://localhost:5173`

## üéØ Algorithms Implemented

### Sorting Algorithms
- [x] **Bubble Sort** - Simple comparison-based sorting
- [x] **Selection Sort** - In-place comparison sorting
- [x] **Insertion Sort** - Builds sorted array one element at a time
- [x] **Merge Sort** - Divide-and-conquer sorting (O(n log n))
- [x] **Quick Sort** - Efficient partition-based sorting

### Searching Algorithms
- [x] **Binary Search** - Logarithmic search on sorted arrays

### Problem-Solving Algorithms
- [x] **Two Sum** - Hash map approach for pair finding
- [x] **Contains Duplicate** - Efficient duplicate detection
- [x] **Maximum Subarray** - Kadane's algorithm
- [x] **Longest Substring Without Repeating** - Sliding window technique
- [x] **Reverse Linked List** - Pointer manipulation
- [x] **Valid Parentheses** - Stack-based validation
- [x] **Climbing Stairs** - Dynamic programming
- [x] **Best Time to Buy and Sell Stock** - Single-pass optimization

## üöÄ Planned Features

### 1. **Interactive Pseudocode Viewer** (Toggleable)
- Display algorithm pseudocode alongside visualization
- Highlight the currently executing line in real-time
- Collapsible panel to maximize screen space when not needed
- Syntax-highlighted code with step annotations

### 2. **Algorithm Comparison Mode**
- Side-by-side comparison of two algorithms
- Synchronized or independent execution controls
- Visual performance comparison on the same dataset
- Ideal for understanding trade-offs between different approaches

### 3. **Complexity Analysis Display**
- Real-time time and space complexity indicators
- Big O notation with explanations
- Operation counters (comparisons, swaps, etc.)
- Memory usage visualization

### 4. **Dynamic Complexity Scenarios**
- Visualize best, average, and worst-case scenarios
- Generate inputs that demonstrate different complexity behaviors
- Educational explanations for why certain inputs trigger specific complexities

### 5. **Linked List Arrows**
- Visual arrows showing node connections
- Pointer manipulation animations
- Clear distinction between next/prev pointers
- Node reference tracking during operations

### 6. **Recursive Call Stack Visualization**
- Dynamic call stack display for recursive algorithms
- Frame-by-frame stack growth and collapse
- Variable state at each recursion level
- Visual representation of recursion tree

### 7. **User-Written Code Execution**
- Code editor for users to write their own algorithms
- Syntax checking and error highlighting
- Execute custom code with the same visualization system
- Compare user solutions with optimal implementations

### 8. **Edge Case Testing Mode**
- Automated edge case generation (empty arrays, duplicates, sorted/reverse sorted)
- Toggle between normal and edge case inputs
- Educational explanations of why edge cases matter
- Test algorithm robustness

### 9. **Interactive Quiz Mode**
- Predict-the-next-step challenges
- Complexity estimation questions
- Algorithm selection for given problems
- Score tracking and learning progress

## üìù License

This project is developed for educational and portfolio purposes.

---

**Built with ‚ù§Ô∏è for algorithm learners everywhere**


